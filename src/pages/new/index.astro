---
import "@milkdown/crepe/theme/common/style.css";
import "@milkdown/crepe/theme/frame.css";
import Layout from "@/layouts/layout.astro";
import { ManagementBar } from "@/components/editor-header";

export const prerender = false;
---

<Layout>
  <div class="w-full flex justify-center relative">
    <div class="w-full max-w-7xl">
      <ManagementBar client:load />
      <div id="app" class="w-full min-h-[70vh]"></div>
      <input
        id="import-md-input"
        type="file"
        accept=".md,text/markdown,text/plain"
        class="hidden"
      />
    </div>
  </div>
</Layout>

<script>
  import { Crepe } from "@milkdown/crepe";
  import { editorViewCtx, prosePluginsCtx } from "@milkdown/core";
  import { keymap } from "@milkdown/prose/keymap";
  import { editorInstance, setCurrentTitle } from "@/store/editor-store";
  import { disposeEmbeddingsClient } from "@/scripts/ai-embeddings";

  let crepeInstance: Crepe | null = null;
  let updateDebounceId: number | null = null;

  // Debounce para evitar procesamiento excesivo en cada keystroke
  function debounce<T extends (...args: any[]) => void>(fn: T, ms: number): T {
    return ((...args: any[]) => {
      if (updateDebounceId) window.clearTimeout(updateDebounceId);
      updateDebounceId = window.setTimeout(() => fn(...args), ms);
    }) as T;
  }

  async function initEditor() {
    if (crepeInstance) {
      crepeInstance.destroy();
      crepeInstance = null;
    }

    crepeInstance = new Crepe({
      root: "#app",
      defaultValue: "# ",
      featureConfigs: {
        placeholder: {
          text: "Nueva pagina",
          mode: "block",
        },
      },
    });

    crepeInstance.editor.config((ctx) => {
      ctx.update(prosePluginsCtx, (prev) => [
        ...prev,
        keymap({
          Backspace: (state) => {
            const { selection } = state;
            const { $from, empty } = selection;

            if (!empty) return false;

            if ($from.index(0) !== 0) return false;

            if ($from.parentOffset !== 0) return false;

            const node = $from.parent;
            if (node.type.name === "heading" && node.attrs.level === 1) {
              return true;
            }

            return false;
          },
        }),
      ]);
    });

    // Handler con debounce para evitar spam en cada keystroke
    const handleUpdate = debounce((ctx: any) => {
      const view = ctx.get(editorViewCtx);
      const { state } = view;
      const firstChild = state.doc.firstChild;

      // Seguridad: Si el documento está vacío, no hacemos nada
      if (!firstChild) return;

      const esTituloH1 =
        firstChild.type.name === "heading" && firstChild.attrs.level === 1;

      // Si NO es H1, lo arreglamos (solo si es necesario)
      if (!esTituloH1) {
        const tr = state.tr.setNodeMarkup(0, state.schema.nodes.heading, {
          level: 1,
        });
        view.dispatch(tr);
        return;
      }

      // Actualizar título solo si cambió
      const textoTitulo = firstChild.textContent.trim() || "Sin título";
      setCurrentTitle(textoTitulo);
    }, 300); // 300ms debounce

    crepeInstance.on((api) => {
      api.updated(handleUpdate);
    });

    await crepeInstance.create();
    editorInstance.set(crepeInstance);
  }

  initEditor();

  document.addEventListener("astro:before-swap", () => {
    // Limpiar debounce pendiente
    if (updateDebounceId) {
      window.clearTimeout(updateDebounceId);
      updateDebounceId = null;
    }

    if (crepeInstance) {
      crepeInstance.destroy();
      crepeInstance = null;
      editorInstance.set(undefined);
    }

    // NO terminamos el worker - preservamos el modelo en memoria
    disposeEmbeddingsClient();
  });
</script>
