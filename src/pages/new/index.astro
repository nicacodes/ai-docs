---
import "@milkdown/crepe/theme/common/style.css";
import "@milkdown/crepe/theme/frame.css";
import Layout from "@/layouts/layout.astro";
import { ManagementBar } from "@/components/editor-header";

export const prerender = false;
---

<Layout>
  <div class="w-full flex justify-center relative">
    <div class="w-full max-w-7xl">
      <ManagementBar client:load />
      <div id="app" class="w-full min-h-[70vh]"></div>
      <input
        id="import-md-input"
        type="file"
        accept=".md,text/markdown,text/plain"
        class="hidden"
      />
    </div>
  </div>
</Layout>

<script>
  import { Crepe } from "@milkdown/crepe";
  import { editorViewCtx, prosePluginsCtx } from "@milkdown/core";
  import { keymap } from "@milkdown/prose/keymap";
  import { editorInstance, setCurrentTitle } from "@/store/editor-store";
  import { disposeEmbeddingsClient } from "@/scripts/ai-embeddings";
  import { loadDraftContent, saveDraftContent } from "@/lib/utils";

  let crepeInstance: Crepe | null = null;
  let updateDebounceId: number | null = null;
  let saveDebounceId: number | null = null;

  // Debounce para evitar procesamiento excesivo en cada keystroke
  function debounce<T extends (...args: any[]) => void>(fn: T, ms: number): T {
    let timeoutId: number | null = null;
    return ((...args: any[]) => {
      if (timeoutId) window.clearTimeout(timeoutId);
      timeoutId = window.setTimeout(() => fn(...args), ms);
    }) as T;
  }

  async function initEditor() {
    if (crepeInstance) {
      crepeInstance.destroy();
      crepeInstance = null;
    }

    // Intentar cargar draft guardado
    const savedDraft = loadDraftContent();
    const initialContent = savedDraft || "# ";

    crepeInstance = new Crepe({
      root: "#app",
      defaultValue: initialContent,
      featureConfigs: {
        placeholder: {
          text: "Nueva pagina",
          mode: "block",
        },
      },
    });

    crepeInstance.editor.config((ctx) => {
      ctx.update(prosePluginsCtx, (prev) => [
        ...prev,
        keymap({
          Backspace: (state) => {
            const { selection } = state;
            const { $from, empty } = selection;

            if (!empty) return false;

            if ($from.index(0) !== 0) return false;

            if ($from.parentOffset !== 0) return false;

            const node = $from.parent;
            if (node.type.name === "heading" && node.attrs.level === 1) {
              return true;
            }

            return false;
          },
        }),
      ]);
    });

    // Handler con debounce para título
    const handleUpdate = debounce((ctx: any) => {
      const view = ctx.get(editorViewCtx);
      const { state } = view;
      const firstChild = state.doc.firstChild;

      // Seguridad: Si el documento está vacío, no hacemos nada
      if (!firstChild) return;

      const esTituloH1 =
        firstChild.type.name === "heading" && firstChild.attrs.level === 1;

      // Si NO es H1, lo arreglamos (solo si es necesario)
      if (!esTituloH1) {
        const tr = state.tr.setNodeMarkup(0, state.schema.nodes.heading, {
          level: 1,
        });
        view.dispatch(tr);
        return;
      }

      // Actualizar título solo si cambió
      const textoTitulo = firstChild.textContent.trim() || "Sin título";
      setCurrentTitle(textoTitulo);
    }, 300);

    // Handler con debounce para guardar draft (más lento para no saturar localStorage)
    const saveDraft = debounce(async () => {
      if (!crepeInstance) return;
      try {
        const markdown = await crepeInstance.getMarkdown();
        saveDraftContent(markdown);
      } catch (e) {
        console.warn("Error obteniendo markdown para draft:", e);
      }
    }, 1000); // Guardar cada 1 segundo después de cambios

    crepeInstance.on((api) => {
      api.updated((ctx) => {
        handleUpdate(ctx);
        saveDraft();
      });
    });

    await crepeInstance.create();
    editorInstance.set(crepeInstance);

    // Si había un draft, actualizar el título
    if (savedDraft) {
      const lines = savedDraft.split(/\r?\n/);
      for (const line of lines) {
        const m = /^\s*#\s+(.+)\s*$/.exec(line);
        if (m?.[1]) {
          setCurrentTitle(m[1].trim());
          break;
        }
      }
    }
  }

  initEditor();

  document.addEventListener("astro:before-swap", () => {
    // Limpiar debounce pendiente
    if (updateDebounceId) {
      window.clearTimeout(updateDebounceId);
      updateDebounceId = null;
    }
    if (saveDebounceId) {
      window.clearTimeout(saveDebounceId);
      saveDebounceId = null;
    }

    if (crepeInstance) {
      crepeInstance.destroy();
      crepeInstance = null;
      editorInstance.set(undefined);
    }

    // NO terminamos el worker - preservamos el modelo en memoria
    disposeEmbeddingsClient();
  });
</script>
