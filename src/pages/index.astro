---
import { Font } from 'astro:assets';
import '@milkdown/crepe/theme/common/style.css';
import '@milkdown/crepe/theme/frame.css';
import '../styles/global.css';
import { Button } from '@/components/ui/button';

export const prerender = false;
---

<html lang='es'>
  <head>
    <meta charset='utf-8' />
    <link rel='icon' type='image/svg+xml' href='/favicon.svg' />
    <meta name='viewport' content='width=device-width' />
    <meta name='generator' content={Astro.generator} />
    <Font cssVariable='--font-inter' preload />
    <title>AI blog</title>
  </head>
  <body>
    <div class='flex justify-center min-h-screen bg-white'>
      <div class='min-w-230 p-9 bg-white'>
        <div class='flex items-center gap-3 mb-4'>
          <Button id='save-btn' variant='outline' client:load>Guardar</Button>
          <div id='save-status' class='text-sm text-gray-600'></div>
        </div>

        <div
          id='progress'
          class='hidden mb-5 space-y-2 rounded-lg border border-gray-200 bg-gray-50 p-3'
        >
          <div class='flex items-center justify-between text-sm text-gray-700'>
            <span id='progress-label'></span>
            <span id='progress-value' class='tabular-nums'></span>
          </div>
          <div class='h-2 rounded-full bg-gray-200 overflow-hidden'>
            <div
              id='progress-bar'
              class='h-full bg-gray-900 transition-all duration-300'
              style='width: 0%'
            >
            </div>
          </div>
        </div>

        <div id='app'></div>
      </div>
    </div>
  </body>
</html>

<script>
  import { Crepe } from '@milkdown/crepe';
  import { actions } from 'astro:actions';
  import {
    clearAllEmbeddingsCaches,
    embedPost,
    ensureSwReady,
    initEmbeddingModel,
    swStatus,
  } from '../scripts/ai-embeddings';

  const MODEL = {
    modelId: 'Xenova/multilingual-e5-large',
    device: 'wasm',
  } as const;
  function inferTitle(md: string): string {
    const lines = String(md || '').split(/\r?\n/);
    for (const line of lines) {
      const m = /^\s*#\s+(.+)\s*$/.exec(line);
      if (m?.[1]) return m[1].trim().slice(0, 120);
    }
    for (const line of lines) {
      const t = line.trim();
      if (t) return t.slice(0, 120);
    }
    return 'Sin título';
  }

  // Nota: Guardar SIEMPRE crea un post nuevo.
  // Por eso no guardamos/recuperamos el documento actual en localStorage.

  const crepe = new Crepe({
    root: '#app',
    defaultValue: '#',
    featureConfigs: {
      placeholder: {
        text: 'Nueva pagina',
        mode: 'block',
      },
    },
  });

  crepe.create().then(() => {
    console.log('Editor created');
  });

  crepe.setReadonly(false);

  const saveBtn = document.querySelector(
    '#save-btn',
  ) as HTMLButtonElement | null;
  /** @type {HTMLElement|null} */
  const saveStatus = document.querySelector('#save-status');
  /** @type {HTMLDivElement|null} */
  const progressBox = document.querySelector('#progress');
  /** @type {HTMLSpanElement|null} */
  const progressLabel = document.querySelector('#progress-label');
  /** @type {HTMLSpanElement|null} */
  const progressValue = document.querySelector('#progress-value');
  /** @type {HTMLDivElement|null} */
  const progressBar = document.querySelector('#progress-bar') as HTMLDivElement;
  /** @type {number|null} */
  let hideProgressTimer: number | null = null;

  const renderProgress = (
    state: { label?: string; percent?: number | null } | null,
  ) => {
    if (!progressBox || !progressLabel || !progressValue || !progressBar)
      return;

    if (hideProgressTimer) {
      window.clearTimeout(hideProgressTimer);
      hideProgressTimer = null;
    }

    if (!state) {
      progressBox.classList.add('hidden');
      progressLabel.textContent = '';
      progressValue.textContent = '';
      progressBar.style.width = '0%';
      progressBar.style.opacity = '1';
      return;
    }

    progressBox.classList.remove('hidden');
    progressLabel.textContent = state.label || '';

    if (state.percent === null || Number.isNaN(state.percent)) {
      progressValue.textContent = '';
      progressBar.style.width = '100%';
      progressBar.style.opacity = '0.35';
      return;
    }

    const pct = Math.max(0, Math.min(100, Math.round(state.percent || 0)));
    progressValue.textContent = `${pct}%`;
    progressBar.style.width = `${pct}%`;
    progressBar.style.opacity = '1';
  };

  const scheduleHideProgress = (delay = 1200) => {
    if (hideProgressTimer) window.clearTimeout(hideProgressTimer);
    hideProgressTimer = window.setTimeout(() => renderProgress(null), delay);
  };

  const normalizeProgressPayload = (payload: any) => {
    if (!payload || typeof payload !== 'object') return null;

    const phase = payload.phase || '';
    const message = payload.label || payload.message;
    const pct = Number.isFinite(payload.percent)
      ? Math.round(payload.percent)
      : null;

    if (
      phase === 'running' &&
      typeof payload.total === 'number' &&
      payload.total > 0
    ) {
      const position =
        typeof payload.index === 'number'
          ? Math.min(payload.index + 1, payload.total)
          : payload.total;
      const percent =
        payload.percent != null
          ? pct
          : Math.round((position / payload.total) * 100);

      return {
        label: `Procesando ${position}/${payload.total}`,
        percent: percent,
      };
    }

    return {
      label: message || 'Descargando modelo',
      percent: pct,
    };
  };

  const handleProgress = (payload: any) => {
    const next = normalizeProgressPayload(payload);
    if (next) renderProgress(next);
  };

  (async () => {
    try {
      renderProgress({ label: 'Cargando modelo', percent: 0 });
      await ensureSwReady();
      console.log('Worker listo para embeddings');

      // Precargar modelo al abrir la página
      await initEmbeddingModel(MODEL, handleProgress);
      renderProgress({ label: 'Modelo listo', percent: 100 });
      scheduleHideProgress();

      // API mínima para probar desde DevTools:
      window.aiEmbeddings = {
        init: initEmbeddingModel,
        embedPost,
        status: swStatus,
        clearCaches: clearAllEmbeddingsCaches,
      };
    } catch (e) {
      console.warn('No se pudo inicializar embeddings:', e);
      renderProgress({ label: 'No se pudo cargar el modelo', percent: null });
    }
  })();

  saveBtn?.addEventListener('click', async () => {
    if (!saveBtn || !saveStatus) return;

    saveBtn.disabled = true;
    saveStatus.textContent = 'Guardando…';
    renderProgress({ label: 'Generando embeddings', percent: 0 });

    try {
      const rawMarkdown = await crepe.getMarkdown();
      const title = inferTitle(rawMarkdown);
      const { data: saved, error: saveError } = await actions.documents.save({
        // Nuevo siempre: no enviar id/slug
        title,
        rawMarkdown,
        metadata: {},
      });

      if (saveError) {
        console.error(saveError);
        saveStatus.textContent = 'Error guardando documento.';
        return;
      }
      // Embedding (1 chunk, todo el documento)
      const embeddingText = `passage: ${rawMarkdown}`;
      const embedding = await embedPost({
        postId: saved.id,
        text: embeddingText,
        model: MODEL,
        onProgress: handleProgress,
      });

      const { error: embError } = await actions.documents.upsertEmbeddings({
        documentId: saved.id,
        items: [
          {
            chunkIndex: 0,
            chunkText: rawMarkdown,
            embedding,
            modelId: MODEL.modelId,
            device: MODEL.device,
            pooling: 'mean',
            normalize: true,
          },
        ],
      });

      if (embError) {
        console.error(embError);
        saveStatus.textContent =
          'Documento guardado; error guardando embedding.';
        return;
      }

      saveStatus.textContent = 'Guardado.';
      renderProgress({ label: 'Embeddings listos', percent: 100 });
      scheduleHideProgress();
    } catch (e) {
      console.error(e);
      saveStatus.textContent = 'Error inesperado al guardar.';
      renderProgress({ label: 'Error generando embedding', percent: null });
    } finally {
      saveBtn.disabled = false;
    }
  });
</script>
